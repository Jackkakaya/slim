// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nodes.proto

package trie

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Bitmap is an array of bits.
//
// Since 0.5.10
type Bitmap struct {
	// Words contains bitmap
	//
	// Since 0.5.10
	Words []uint64 `protobuf:"varint,20,rep,packed,name=Words,proto3" json:"Words,omitempty"`
	// RankIndex speeds up rank() by pre-calcuate it
	//
	// Since 0.5.10
	RankIndex []int32 `protobuf:"varint,30,rep,packed,name=RankIndex,proto3" json:"RankIndex,omitempty"`
	// SelectIndex speeds up select() by pre-calcuate it
	//
	// Since 0.5.10
	SelectIndex          []int32  `protobuf:"varint,40,rep,packed,name=SelectIndex,proto3" json:"SelectIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Bitmap) Reset()         { *m = Bitmap{} }
func (m *Bitmap) String() string { return proto.CompactTextString(m) }
func (*Bitmap) ProtoMessage()    {}
func (*Bitmap) Descriptor() ([]byte, []int) {
	return fileDescriptor_nodes_da8a55c5c5cffbb1, []int{0}
}
func (m *Bitmap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Bitmap.Unmarshal(m, b)
}
func (m *Bitmap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Bitmap.Marshal(b, m, deterministic)
}
func (dst *Bitmap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bitmap.Merge(dst, src)
}
func (m *Bitmap) XXX_Size() int {
	return xxx_messageInfo_Bitmap.Size(m)
}
func (m *Bitmap) XXX_DiscardUnknown() {
	xxx_messageInfo_Bitmap.DiscardUnknown(m)
}

var xxx_messageInfo_Bitmap proto.InternalMessageInfo

func (m *Bitmap) GetWords() []uint64 {
	if m != nil {
		return m.Words
	}
	return nil
}

func (m *Bitmap) GetRankIndex() []int32 {
	if m != nil {
		return m.RankIndex
	}
	return nil
}

func (m *Bitmap) GetSelectIndex() []int32 {
	if m != nil {
		return m.SelectIndex
	}
	return nil
}

// Nodes is array of all inner nodes in slim trie.
// It is NOT a public type and do not rely on it.
// Since protobuf just makes all message public.
//
// Since 0.5.10
type Nodes struct {
	// WithLeaves indicates whether to store leaf values(as an index).
	// Otherwise, it is a "filter" which can only provide existence information
	// but not location information.
	//
	// Since 0.5.10
	WithLeaves bool `protobuf:"varint,8,opt,name=WithLeaves,proto3" json:"WithLeaves,omitempty"`
	// WithPrefixContent indicates whether full inner prefixes are stored or only the
	// lengths of inner prefix are stored.
	//
	// Since 0.5.10
	WithPrefixContent bool `protobuf:"varint,9,opt,name=WithPrefixContent,proto3" json:"WithPrefixContent,omitempty"`
	// WithLeafPrefix indicates whether to store prefix of leaves.
	//
	// Since 0.5.10
	WithLeafPrefix bool `protobuf:"varint,10,opt,name=WithLeafPrefix,proto3" json:"WithLeafPrefix,omitempty"`
	// BigInnerCnt is number of big (267 bit) inner node.
	//
	// Since 0.5.10
	BigInnerCnt int32 `protobuf:"varint,11,opt,name=BigInnerCnt,proto3" json:"BigInnerCnt,omitempty"`
	// BigInnerOffset is the offset caused by "BigInner" nodes:
	//
	// Supposing that the i-th inner node is the j-th short inner node(an inner
	// node can be a short).
	//
	// The offset of this node in "Inners" is
	//
	//     257 * BigInnerCnt +
	//     17 * (i-BigInnerCnt-j) +
	//     ShortSize * j
	//
	// Thus we could create 2 variables to reduce offset calculation time:
	//
	//     BigInnerOffset = (257 - 17) * BigInnerCnt
	//     ShortMinusInner = ShortSize - 17
	//
	// The the offset is:
	//
	//     BigInnerOffset + 17 * i + ShortMinusInner * j
	//
	// Since 0.5.10
	BigInnerOffset int32 `protobuf:"varint,12,opt,name=BigInnerOffset,proto3" json:"BigInnerOffset,omitempty"`
	// ShortMinusInner is ShortSize minus 17.
	// See BigInnerOffset.
	//
	// Since 0.5.10
	ShortMinusInner int32 `protobuf:"varint,13,opt,name=ShortMinusInner,proto3" json:"ShortMinusInner,omitempty"`
	// ShortSize is the number of bit of short bitmap that reduce most memory
	// cost.
	//
	// Since 0.5.10
	ShortSize int32 `protobuf:"varint,14,opt,name=ShortSize,proto3" json:"ShortSize,omitempty"`
	// ShortMask has the lower ShortSize bit set to 1.
	//
	// Since 0.5.10
	ShortMask uint64 `protobuf:"varint,15,opt,name=ShortMask,proto3" json:"ShortMask,omitempty"`
	// Number of InnerPrefixes.
	// It is used to speed up lookup when there are not any prefixes.
	//
	// Since 0.5.10
	InnerPrefixCnt int32 `protobuf:"varint,16,opt,name=InnerPrefixCnt,proto3" json:"InnerPrefixCnt,omitempty"`
	// NodeTypeBM is a bitmap in which a "1" indicates the i-th node is an inner
	// node, otherwise it is a leaf.
	//
	// Since 0.5.10
	NodeTypeBM *Bitmap `protobuf:"bytes,20,opt,name=NodeTypeBM,proto3" json:"NodeTypeBM,omitempty"`
	// Inners is a array of var-length node label bitmaps.
	// The size of an element bitmap is aligned to 4.
	//
	// Since 0.5.10
	Inners *Bitmap `protobuf:"bytes,30,opt,name=Inners,proto3" json:"Inners,omitempty"`
	// ShortBM indicate most used inner node bitmaps.
	// These nodes takes 4 bits and the actual bitmaps are stored separate.
	//
	// Since 0.5.10
	ShortBM *Bitmap `protobuf:"bytes,31,opt,name=ShortBM,proto3" json:"ShortBM,omitempty"`
	// ShortTable is a mapping of short bitmap to full 17-bit bitmap.
	//
	// Since 0.5.10
	ShortTable []uint32 `protobuf:"varint,32,rep,packed,name=ShortTable,proto3" json:"ShortTable,omitempty"`
	// InnerPrefixBM indicates whether an inner node has a prefix.
	// Its bit index is inner node index but not node-id.
	//
	// Since 0.5.10
	InnerPrefixBM *Bitmap `protobuf:"bytes,50,opt,name=InnerPrefixBM,proto3" json:"InnerPrefixBM,omitempty"`
	// InnerPrefixLens stores how many bits to move forword before looking up a key on an
	// inner node.
	// The length of this array is len(inner nodes).
	// Whether an inner node has prefix is stored in InnerPrefixBM.
	//
	// Since 0.5.10
	InnerPrefixLens []byte `protobuf:"bytes,51,opt,name=InnerPrefixLens,proto3" json:"InnerPrefixLens,omitempty"`
	// InnerPrefixStartBM is a bitmap of starting position of a prefix. aligned to 8.
	//
	// Since 0.5.10
	InnerPrefixStartBM *Bitmap `protobuf:"bytes,52,opt,name=InnerPrefixStartBM,proto3" json:"InnerPrefixStartBM,omitempty"`
	// InnerPrefixes of inner nodes.
	// An array element is a control byte followed by several data bytes.
	//
	// The 0-th bit in the control byte indicates whether a prefix is
	// trucated(not aligned to 8-bit).
	//
	// An inner node may have a prefix, if the starting bit of the node > the end
	// of previous node.
	//
	// The end of a prefix may not be 8-bit aligned.
	// Thus we need a bitmap to indicated this.
	// If prefix length is not 8-bit aligned, the trailing bits a filled with a
	// "1" followed by "0"s.
	// To retrieve the acturate prefix, remove the bits from the last "1".
	// E.g.:
	//
	//   prefix:                  11001100 11000011
	//   stored prefix:  00000000 11001100 11010011;  control byte = 0
	//
	//   prefix:                  11001100 110
	//   stored prefix:  00000001 11001100 11010000;  control byte = 1
	//
	// Since 0.5.10
	InnerPrefixes []byte `protobuf:"bytes,54,opt,name=InnerPrefixes,proto3" json:"InnerPrefixes,omitempty"`
	// LeafBytes stores serialized leaf values.
	//
	// Since 0.5.10
	LeafBytes []byte `protobuf:"bytes,60,opt,name=LeafBytes,proto3" json:"LeafBytes,omitempty"`
	// LeafPrefixBM indicates whether a leaf node has a prefix.
	// Its bit index is leaf node index but not node-id.
	//
	// Since 0.5.10
	LeafPrefixBM *Bitmap `protobuf:"bytes,61,opt,name=LeafPrefixBM,proto3" json:"LeafPrefixBM,omitempty"`
	// LeafPrefixStartBM is a bitmap of starting position of a prefix. aligned to 8.
	//
	// Since 0.5.10
	LeafPrefixStartBM *Bitmap `protobuf:"bytes,62,opt,name=LeafPrefixStartBM,proto3" json:"LeafPrefixStartBM,omitempty"`
	// LeafPrefixes are prefixes of leaf nodes.
	//
	// Since 0.5.10
	LeafPrefixes         []byte   `protobuf:"bytes,63,opt,name=LeafPrefixes,proto3" json:"LeafPrefixes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Nodes) Reset()         { *m = Nodes{} }
func (m *Nodes) String() string { return proto.CompactTextString(m) }
func (*Nodes) ProtoMessage()    {}
func (*Nodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_nodes_da8a55c5c5cffbb1, []int{1}
}
func (m *Nodes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Nodes.Unmarshal(m, b)
}
func (m *Nodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Nodes.Marshal(b, m, deterministic)
}
func (dst *Nodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Nodes.Merge(dst, src)
}
func (m *Nodes) XXX_Size() int {
	return xxx_messageInfo_Nodes.Size(m)
}
func (m *Nodes) XXX_DiscardUnknown() {
	xxx_messageInfo_Nodes.DiscardUnknown(m)
}

var xxx_messageInfo_Nodes proto.InternalMessageInfo

func (m *Nodes) GetWithLeaves() bool {
	if m != nil {
		return m.WithLeaves
	}
	return false
}

func (m *Nodes) GetWithPrefixContent() bool {
	if m != nil {
		return m.WithPrefixContent
	}
	return false
}

func (m *Nodes) GetWithLeafPrefix() bool {
	if m != nil {
		return m.WithLeafPrefix
	}
	return false
}

func (m *Nodes) GetBigInnerCnt() int32 {
	if m != nil {
		return m.BigInnerCnt
	}
	return 0
}

func (m *Nodes) GetBigInnerOffset() int32 {
	if m != nil {
		return m.BigInnerOffset
	}
	return 0
}

func (m *Nodes) GetShortMinusInner() int32 {
	if m != nil {
		return m.ShortMinusInner
	}
	return 0
}

func (m *Nodes) GetShortSize() int32 {
	if m != nil {
		return m.ShortSize
	}
	return 0
}

func (m *Nodes) GetShortMask() uint64 {
	if m != nil {
		return m.ShortMask
	}
	return 0
}

func (m *Nodes) GetInnerPrefixCnt() int32 {
	if m != nil {
		return m.InnerPrefixCnt
	}
	return 0
}

func (m *Nodes) GetNodeTypeBM() *Bitmap {
	if m != nil {
		return m.NodeTypeBM
	}
	return nil
}

func (m *Nodes) GetInners() *Bitmap {
	if m != nil {
		return m.Inners
	}
	return nil
}

func (m *Nodes) GetShortBM() *Bitmap {
	if m != nil {
		return m.ShortBM
	}
	return nil
}

func (m *Nodes) GetShortTable() []uint32 {
	if m != nil {
		return m.ShortTable
	}
	return nil
}

func (m *Nodes) GetInnerPrefixBM() *Bitmap {
	if m != nil {
		return m.InnerPrefixBM
	}
	return nil
}

func (m *Nodes) GetInnerPrefixLens() []byte {
	if m != nil {
		return m.InnerPrefixLens
	}
	return nil
}

func (m *Nodes) GetInnerPrefixStartBM() *Bitmap {
	if m != nil {
		return m.InnerPrefixStartBM
	}
	return nil
}

func (m *Nodes) GetInnerPrefixes() []byte {
	if m != nil {
		return m.InnerPrefixes
	}
	return nil
}

func (m *Nodes) GetLeafBytes() []byte {
	if m != nil {
		return m.LeafBytes
	}
	return nil
}

func (m *Nodes) GetLeafPrefixBM() *Bitmap {
	if m != nil {
		return m.LeafPrefixBM
	}
	return nil
}

func (m *Nodes) GetLeafPrefixStartBM() *Bitmap {
	if m != nil {
		return m.LeafPrefixStartBM
	}
	return nil
}

func (m *Nodes) GetLeafPrefixes() []byte {
	if m != nil {
		return m.LeafPrefixes
	}
	return nil
}

func init() {
	proto.RegisterType((*Bitmap)(nil), "Bitmap")
	proto.RegisterType((*Nodes)(nil), "Nodes")
}

func init() { proto.RegisterFile("nodes.proto", fileDescriptor_nodes_da8a55c5c5cffbb1) }

var fileDescriptor_nodes_da8a55c5c5cffbb1 = []byte{
	// 443 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0x4f, 0x6f, 0xd3, 0x40,
	0x10, 0xc5, 0x15, 0x25, 0x71, 0xdb, 0x49, 0xd2, 0xd2, 0x51, 0x0e, 0x73, 0x40, 0xe9, 0x12, 0x21,
	0x58, 0x09, 0xe8, 0xa1, 0xe5, 0xcf, 0x85, 0x3f, 0x92, 0x7b, 0xaa, 0x54, 0x03, 0x72, 0x2a, 0x55,
	0xe2, 0x80, 0xe4, 0x92, 0x09, 0xb5, 0x5a, 0xd6, 0x91, 0x77, 0x41, 0x2d, 0x9f, 0x8e, 0x8f, 0x86,
	0x76, 0x9c, 0xe0, 0xdd, 0x94, 0x5b, 0xe6, 0xf7, 0xde, 0xce, 0xbc, 0xec, 0xac, 0x61, 0x60, 0xaa,
	0x39, 0xdb, 0xc3, 0x65, 0x5d, 0xb9, 0x6a, 0xfa, 0x15, 0x92, 0xb4, 0x74, 0x3f, 0x8a, 0x25, 0x8e,
	0xa1, 0x7f, 0x51, 0xd5, 0x73, 0x4b, 0x63, 0xd5, 0xd5, 0xbd, 0xbc, 0x29, 0xf0, 0x21, 0xec, 0xe4,
	0x85, 0xb9, 0x3e, 0x35, 0x73, 0xbe, 0xa5, 0x89, 0xea, 0xea, 0x7e, 0xde, 0x02, 0x54, 0x30, 0x98,
	0xf1, 0x0d, 0x7f, 0x73, 0x8d, 0xae, 0x45, 0x0f, 0xd1, 0xf4, 0x4f, 0x02, 0xfd, 0x8f, 0x7e, 0x1e,
	0x4e, 0x00, 0x2e, 0x4a, 0x77, 0x75, 0xc6, 0xc5, 0x2f, 0xb6, 0xb4, 0xad, 0x3a, 0x7a, 0x3b, 0x0f,
	0x08, 0x3e, 0x87, 0x7d, 0x5f, 0x7d, 0xae, 0x79, 0x51, 0xde, 0x9e, 0x54, 0xc6, 0xb1, 0x71, 0xb4,
	0x23, 0xb6, 0xfb, 0x02, 0x3e, 0x81, 0xdd, 0xd5, 0xd9, 0x45, 0x23, 0x10, 0x88, 0x75, 0x83, 0xfa,
	0x84, 0x69, 0xf9, 0xfd, 0xd4, 0x18, 0xae, 0x4f, 0x8c, 0xa3, 0x81, 0xea, 0xf8, 0x84, 0x01, 0xf2,
	0x9d, 0xd6, 0xe5, 0xa7, 0xc5, 0xc2, 0xb2, 0xa3, 0xa1, 0x98, 0x36, 0x28, 0x6a, 0xd8, 0x9b, 0x5d,
	0x55, 0xb5, 0xcb, 0x4a, 0xf3, 0xd3, 0x8a, 0x40, 0x23, 0x31, 0x6e, 0x62, 0x7f, 0x67, 0x82, 0x66,
	0xe5, 0x6f, 0xa6, 0x5d, 0xf1, 0xb4, 0xe0, 0x9f, 0x9a, 0x15, 0xf6, 0x9a, 0xf6, 0x54, 0x47, 0xf7,
	0xf2, 0x16, 0xf8, 0x34, 0xd2, 0x64, 0xf5, 0x6f, 0x8d, 0xa3, 0x07, 0x4d, 0x9a, 0x98, 0xe2, 0x53,
	0x00, 0x7f, 0xad, 0xe7, 0x77, 0x4b, 0x4e, 0x33, 0x1a, 0xab, 0x8e, 0x1e, 0x1c, 0x6d, 0x1d, 0x36,
	0xab, 0xcc, 0x03, 0x09, 0x0f, 0x20, 0x91, 0xa3, 0x96, 0x26, 0xb1, 0x69, 0x85, 0xf1, 0x11, 0x6c,
	0xc9, 0xf8, 0x34, 0xa3, 0x83, 0xd8, 0xb1, 0xe6, 0x7e, 0x75, 0xf2, 0xf3, 0xbc, 0xb8, 0xbc, 0x61,
	0x52, 0xaa, 0xab, 0x47, 0x79, 0x40, 0xf0, 0x05, 0x8c, 0x82, 0x78, 0x69, 0x46, 0x47, 0x71, 0xa3,
	0x58, 0xf5, 0x37, 0x19, 0x80, 0x33, 0x36, 0x96, 0x8e, 0x55, 0x47, 0x0f, 0xf3, 0x4d, 0x8c, 0x6f,
	0x00, 0x03, 0x34, 0x73, 0x85, 0xc4, 0x7c, 0x19, 0x77, 0xff, 0x8f, 0x05, 0x1f, 0x47, 0x89, 0xd8,
	0xd2, 0x6b, 0x19, 0x10, 0x43, 0xbf, 0x0a, 0xff, 0x54, 0xd2, 0x3b, 0xc7, 0x96, 0xde, 0x8a, 0xa3,
	0x05, 0xf8, 0x0c, 0x86, 0xed, 0x43, 0x4a, 0x33, 0x7a, 0x17, 0x8f, 0x8d, 0x44, 0x7c, 0x05, 0xfb,
	0x6d, 0xbd, 0x0e, 0xfa, 0x3e, 0x3e, 0x71, 0xdf, 0x81, 0xd3, 0x70, 0x06, 0x5b, 0xfa, 0x20, 0x21,
	0x22, 0x96, 0x26, 0x5f, 0x7a, 0xae, 0x2e, 0xf9, 0x32, 0x91, 0x2f, 0xf6, 0xf8, 0x6f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x0d, 0xa4, 0xe0, 0xae, 0xc0, 0x03, 0x00, 0x00,
}
